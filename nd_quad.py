import numpy as np
from itertools import product
from typing import Callable, Tuple, List, Union


# Generate Legendre-Gauss('LL') quadrature points and weights
def getQuad(npoints: int = 2, ndim: int = 1) -> Tuple[np.ndarray, np.ndarray]:
    """
    Return Legendre-Gauss('LL') quadrature points and weights
    Parameters
    ----------
    npoints : int, optional
        Number of quadrature points, by default 2
    ndim : int, optional
        Number of dimensions, by default 1
    Returns
    -------
    x : ndarray
        Quadrature points
    w : ndarray
        Quadrature weights
    """
    # npoints and ndim must be positive integers
    if not isinstance(npoints, int) or not isinstance(ndim, int):
        raise TypeError("npoints and ndim must be positive integers")
    if npoints < 1 or ndim < 1:
        raise ValueError("npoints and ndim must be positive integers")

    # Legendre-Gauss('LL') quadrature points and weights in 1D
    x, w = np.polynomial.legendre.leggauss(npoints)
    # Generate quadrature points and weights in ndim
    x = np.array(list(product(x, repeat=ndim)))
    w = np.prod(np.array(list(product(w, repeat=ndim))), axis=1) 
    return x, w


# Transform points and weights generated by getQuad from [-1, 1] to [x1, x2]
def transformQuad(x: np.ndarray, w: np.ndarray, limits: List[List[float]]) -> Tuple[np.ndarray, np.ndarray]:
    """
    Transform points and weights generated by getQuad from [-1, 1] to [x1, x2]
    Parameters
    ----------
    x : ndarray
        Quadrature points
    w : ndarray
        Quadrature weights
    limits : list
        for eg.:[[x1, x2], [y1, y2]] are the lower and upper bounds
        of the integral in each dimension respectively (in case of 2D)
    Returns
    -------
    x : ndarray
        Quadrature points transformed
    w : ndarray
        Quadrature weights transformed
    """
    # limits must be a list of lists
    if not isinstance(limits, list):
        raise TypeError("limits must be a list of lists")
    # limits must be a list of lists of floats or integers
    for i in range(len(limits)):
        if not isinstance(limits[i], list):
            raise TypeError("limits must be a list of lists of floats")
        for j in range(len(limits[i])):
            if not isinstance(limits[i][j], (float, int)):
                raise TypeError("limits must be a list of lists of floats")
    # limits must be a list of lists of length 2
    for i in range(len(limits)):
        if len(limits[i]) != 2:
            raise ValueError("limits must be a list of lists of length 2")
    # lower bound must be less than upper bound
    for i in range(len(limits)):
        if limits[i][0] >= limits[i][1]:
            raise ValueError("lower bound must be less than upper bound")
    # Points should have the same number of dimensions as limits
    if x.shape[1] != len(limits):
        raise ValueError("Points should have the same number of dimensions as limits")

    # Transform points and weights
    # Use broadcasting to transform points and weights
    # Convert limits to numpy array
    limits = np.array(limits)
    x = (limits[:, 1] - limits[:, 0])/2 * x + (limits[:, 0] + limits[:, 1])/2
    w = w * np.prod((limits[:, 1] - limits[:, 0])/2)
    return x, w


# Numerical integration using Legendre-Gauss('LL') quadrature
def integrateQuad(f: Callable, limits: List[List[float]], npoints: int = 2) -> Union[float, np.ndarray]:
    """
    Numerical integration using Legendre-Gauss('LL') quadrature
    Parameters
    ----------
    f : function
        Function to be integrated
    limits : list
        for eg.:[[x1, x2], [y1, y2]] are the lower and upper bounds
        of the integral in each dimension respectively (in case of 2D)
    npoints : int
        Number of quadrature points, by default 2
    Returns
    -------
    res : float or ndarray
        Result of the numerical integration
    """
    # f must be a function
    if not callable(f):
        raise TypeError("f must be a function")
    # len(limits) must be equal to the number of dimensions of f
    if len(limits) != f.__code__.co_argcount:
        raise ValueError("len(limits) must be equal to the number of dimensions of f")

    # Generate quadrature points and weights
    x, w = getQuad(npoints, ndim=len(limits))
    # Transform quadrature points and weights
    x, w = transformQuad(x, w, limits)
    # Evaluate function at quadrature points
    y = f(*x.T)
    # Calculate result
    res = np.sum(w * y)
    return res


if __name__ == "__main__":
    # Define function to be integrated
    def f(x: np.ndarray, y: np.ndarray) -> np.ndarray:
        return x**2 + y**2
    # Define limits
    limits = [[-1., 1], [-1, 1]]
    # Calculate integral
    res = integrateQuad(f, limits, 2, 2)
    print(res)